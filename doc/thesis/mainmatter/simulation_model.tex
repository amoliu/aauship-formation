\chapter{Simulation Model}
\label{ch:simulation-model}
\head{This chapter will describe the model
that is used for simulation of the system, as a replacement for
testing on the real ship.}

To make a model for simulation model, it is needed to emulate the real
sensor outputs with noise imposed onto the signals. Using a \ac{LTI}
state space model based on the unified model \vref{eq:totmodel} is
constructed as \vref{eq:ss} as defined by \citep[p. 175]{fossen}.

\begin{subequations}
\begin{align}
	\dot x &=  A x + B u + E w \\
	y &= H x + v \\
	A &=
	\begin{bmatrix}
		0 & I\\ -M^{-1}G & -M^{-1}D
	\end{bmatrix}, \quad
	B = 
	\begin{bmatrix}
		0 \\ M^{-1}
	\end{bmatrix}, \quad
	E =
	\begin{bmatrix}
		0 \\ M^{-1}
	\end{bmatrix}
\end{align}
\label{eq:ss}
\end{subequations}

The matrix $E$ describes the sea state and vector $w$ the process noise, and $v$ the sensor (measurement) noise. Both noise
vectors are assumed zero-mean Gaussian white noise processes.

\nomenclature{$x_n, y_n$}{Position in the \acs{NED}-frame, usually
computed from a \acs{GPS}}
\nomenclature{$a_x, a_y, a_z$}{Linear accelerations from accelerometer}
\nomenclature{$m_x, m_y, m_z$}{Magnetic field from magnetometer}
\nomenclature{$\omega_x, \omega_y, \omega_z$}{Angular velocity from rate gyro}
\nomenclature{$\psi$}{Heading angle (yaw)}
\nomenclature{$\mathbf{p}^n _{b/n}$}{Linear position of $o_b$ with respect to ${n}$ expressed in ${n}$}
\nomenclature{$\boldsymbol{\Theta}_{nb}$}{Euler angles between ${n}$ and ${b}$}


\section{Position Trajectory in \acs{NED}}
The positon trajectory \vref{eq:NEDtrajectory} in \ac{NED} is calculated with numerical Euler integration of the velocities \vref{eq:NEDvel}.
\begin{subequations}
\begin{align}
\dot{\mathbf{p}}^n _{b/n} &= \mathbf{R}^n _b (\boldsymbol{\Theta}_{nb}) \boldsymbol{\nu}^b _{b/n} \label{eq:NEDvel}\\
\mathbf{p}^n _{b/n}(k+1) &= \mathbf{p}^n _{b/n}(k) + h \dot{\mathbf{p}}^n _{b/n} \label{eq:NEDtrajectory} \\
&= \mathbf{p}^n _{b/n}(k) + h \mathbf{R}^n _b (\boldsymbol{\Theta}_{nb}(k)) \boldsymbol{\nu}^b _{b/n}(k) 
\end{align}
\end{subequations}
The generalised position, velocity, acceleration and force vectors, in that order, is:
\begin{align}
\boldsymbol{\eta} =
\begin{bmatrix}
\mathbf{p}^n _{b/n}\\\boldsymbol{\Theta}_{nb}
\end{bmatrix},\qquad
\boldsymbol{\nu} =
\begin{bmatrix}
\boldsymbol{\nu}^b _{b/n}\\\boldsymbol{\omega}^b _{nb}
\end{bmatrix},\qquad
\dot{\boldsymbol{\nu}} =
\begin{bmatrix}
\dot{\boldsymbol{\nu}}^b _{b/n}\\\dot{\boldsymbol{\omega}}^b _{n/b}
\end{bmatrix},\qquad
\boldsymbol{\tau} =
\begin{bmatrix}
\mathbf{f}^b _b\\\mathbf{m}^b _b
\end{bmatrix}
\end{align}

\section{Sensor Measurements to State Vector}
For the control system it is needed to convert the sensor measurements
to the system state vector, such that the control system can be
designed. Figure~\vref{fig:intermediate-calc} shows the computation
flow to determine this. It shall be noted that the \ac{GPS} and
\ac{IMU} blocks has the sensor noise in them.

Now that the state vector is present an state observer can be used for
in i.e. a Kalman filter to reduce the noise.

\begin{figure}
	\centering
	\includesvg{intermediate-sensor-calculations-block}
	\caption{Block diagram over the computation of system states from
	raw sensor measurements.}
	\label{fig:intermediate-calc}
\end{figure}

Since the simulation is performed by iterating over the state space
model, it is needed to somehow get the variances from the sensors
modelled in the state space model. Because of the intermediate
computations described in the figure~\vref{fig:intermediate-calc} it
is not straight forward to add the sensor noise to the model, because
this noise is specified at the raw sensor measurements. So some way
has to be used to calculate the noise $v$.

A method is the simply set the inputs as the variance value and the
output will be the variance in the state vector. \todo{Is this true?}

A method is to set the sensor measurements to no movement values, and
only add the noise on the measurements. I all sensors were zero in
stagnation, then it would be enough to simulate this with only noise and
get the corresponding variance out. This is not the case, as the
magnetometer has a bias, just because it is situated in a constant
magnetic field and this is dependent on the attitude of the ship. So
to compute the variances on the state vector it is needed to make
multiple simulations where this bias is different also. A normalized
normal distribution of this should suffice. \todo{Is this good enough
or even correct? We have nonlinearities.}

\section{\acs{SOG} to body frame velocities}
The \acl{SOG} block on the figure~\vref{fig:intermediate-calc} is used to calculate the body frame velocities in surge $u$ and sway $v$, which in turn is filtered by the Kalman filter described in section~\vref{sec:kfdesign}. The block on the diagram uses the \ac{SOG} from the \ac{GPS}, denoted as the magnitude $U$ and the course angle relative to true north, denoteed the course angle $\chi$. Which is the sum of the heading $\psi$ and sidelip $\beta$ angles:
\nomenclature{$\chi$}{Course angle}
\nomenclature{$\beta$}{Sideslip angle}
\nomenclature{$U$}{Course speed}
\begin{align}
\chi = \psi + \beta \quad \Rightarrow  \quad \beta = \chi - \psi
\end{align}

To calculate the body frame velocites the rotation matrix around $z$ is used. It is enough to use this one basic rotaiton, becasue this is on the 2D system ($x,y$) in the \ac{NED} frame.

\begin{align}
R_{z} (\psi) =
\begin{bmatrix}
\cos(\psi) & -\sin(\psi)\\
\sin(\psi) & \cos(\psi)
\end{bmatrix}
\label{eq:Rz}
\end{align}
First the course speed magnitude $U$ can be calculated in \ac{NED} by the following computation, where we describe the course speed as a vector $[U\quad 0]^\top$, such that the 
\begin{align}
U_n = R_{z} (\chi)
\begin{bmatrix}
U \\ 0 
\end{bmatrix}
=
\begin{bmatrix}
\cos(\chi) \\
\sin(\chi)
\end{bmatrix}
U
\end{align}
Now this can be rotated into \ac{BODY}, using the same rotation matrix \vref{eq:Rz}, but with the sidelip angle instead of the course angle. Such that:
\begin{align}
U_b = \begin{bmatrix}
u \\ v
\end{bmatrix}
= R_z (\beta) U_n
\end{align}
Assuming the course speed vector in relation to the \ac{BODY} (as opposed to \ac{NED} initially suggested) it is enough to use the sideslip for rotation directly.
\begin{align}
U_b = R_{z} (\beta)
\begin{bmatrix}
U \\ 0 
\end{bmatrix}
=
\begin{bmatrix}
\cos(\beta) \\
\sin(\beta)
\end{bmatrix}
U
\end{align}

\todo{Add figure about this}
